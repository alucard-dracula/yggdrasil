/* Copyright ?2000 
Michael Gradman and Corwin Joy 

Permission to use, copy, modify, distribute and sell this software and 
its documentation for any purpose is hereby granted without fee, provided 
that the above copyright notice appears in all copies and that both that 
copyright notice and this permission notice appear in supporting documentation. 
Corwin Joy and Michael Gradman make no representations about the suitability 
of this software for any purpose. 
It is provided "as is" without express or implied warranty.
*/ 

// Edited: 10/26/2003 - Paul Grenyer http://www.paulgrenyer.co.uk, added static_cast as required by MSVC 7.1


#include "DBException.h"
#include "DBConnection.h"
#include "DBStmt.h"
#include "clib_fwd.h"

BEGIN_DTL_NAMESPACE

// ****************** implementation code for DBException ******************************
	STD_::vector<DBException::ODBCErrorInfo> 
	   DBException::ShowSQLErrors(const DBConnection *pConn, const DBStmt *pStmt)
	{		
	   TCHAR szSQLSTATE[6];
	   SDWORD nErr;
	   TCHAR msg[SQL_MAX_MESSAGE_LENGTH + 200];
	   SWORD cbmsg;

	   DBConnection *conn = const_cast<DBConnection *>(pConn);
	   DBStmt		*stmt = const_cast<DBStmt *>(pStmt);

	   HENV henv = (conn ? GetHENV(*conn) : SQL_NULL_HENV);
	   HDBC hdbc = (conn ? GetHDBC(*conn) : SQL_NULL_HDBC);
	   HSTMT hstmt = (stmt ? GetHSTMT(*stmt) : SQL_NULL_HSTMT);

	   STD_::vector<ODBCErrorInfo> errors;

	   if (henv == SQL_NULL_HENV && hdbc == SQL_NULL_HDBC && hstmt == SQL_NULL_HSTMT) return errors;

       while (SQLError(henv, hdbc, hstmt, (SQLTCHAR *)szSQLSTATE, &nErr, (SQLTCHAR *)msg, sizeof(msg)-1, &cbmsg) == SQL_SUCCESS) 
	   {
		  // MessageBox(NULL, (TCHAR *)msg, (TCHAR *)szSQLSTATE,MB_OK);
		  // Note: if we're inserting into the database we have to take out
		  // the single quotes containing the msg.

		  tostringstream statestr;
		  statestr << szSQLSTATE;

		  tostringstream msgstr;
		  msgstr << msg;

		  tstring statestring = statestr.str();

		  tstring msgstring = msgstr.str();

		  ODBCErrorInfo info(statestring, nErr, msgstring);

		  errors.push_back(info);
	   }

	   return errors;
	}

	DBException::DBException(const tstring &meth, const tstring &msg,
			const DBConnection *pConn, const DBStmt *pStmt) : 
			RootException(meth, msg, _TEXT("DBException")), 
			sqlErrors(ShowSQLErrors(pConn, pStmt))
	{
		// write out msg to error log
	
	}

	const TCHAR *DBException::twhat() const throw()
	{
	   tstring rootWhat = RootException::twhat();
	   tostringstream o;
	   o << rootWhat;

	   if (sqlErrors.size() > 0)
	   {
		  o << _TEXT("SQL Errors: ") << STD_::endl;
		  
		  for (size_t i = 0; i < sqlErrors.size(); i++)
		  {
			  o << _TEXT("(") << static_cast<int>(i) << _TEXT(") ") << sqlErrors[i] << STD_::endl; 
		  }

	   }
	   o << STD_::ends;

	   // this gymnastics is needed so result isn't destroyed
	   // paste these two lines into all what() code
	   whatbuf = o.str();
	   return whatbuf.c_str();
	}

	const char *DBException::what() const throw()
	{
#ifndef DTL_NO_UNICODE
	   whatbuf_narrow = tstring_cast((STD_::string *)NULL, twhat());
	   return whatbuf_narrow.c_str();
#else
	   return twhat();
#endif
	}

	// gets the true ODBC error code that caused the exception
	// this will be the szSQLState member of the first element
	// of the sqlErrors STD_::vector
	// returns empty tstring if no ODBC error occurred

	STD_::pair<tstring, tstring> DBException::GetODBCError() const
	{
		if (sqlErrors.empty())
			return STD_::make_pair(tstring(_TEXT("")), tstring(_TEXT("")));
		else
		{
			STD_::vector<ODBCErrorInfo>::const_iterator it = sqlErrors.begin();
			tstring msg;
			while (it != sqlErrors.end()) {
				msg += (*it).errMsg;
				msg += _TEXT("; ");
				++it;
			}
			return STD_::make_pair((*sqlErrors.begin()).szSQLState, msg);
		}
	}
	// returns the entire error STD_::vector generated by the exception
	STD_::vector<DBException::ODBCErrorInfo> DBException::GetAllODBCErrors() const
	{
		return sqlErrors;
	}

END_DTL_NAMESPACE
